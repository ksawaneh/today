# Agent Best Practices: Avoiding AI Slop

This document defines quality standards for each agent to ensure output is exceptional, not generic.

---

## What Is "AI Slop"?

AI slop is output that:
- Could have been generated by any AI with zero context
- Uses generic patterns without understanding why
- Prioritizes "looking complete" over being useful
- Lacks personality, opinion, or point of view
- Is technically correct but spiritually empty

**The antidote: intentionality.** Every decision should have a reason.

---

## Universal Anti-Patterns (All Agents)

### ‚ùå Never Do

1. **Generic explanations nobody asked for**
   ```
   Bad:  "I'll help you create a task management system. Task management 
         is important for productivity..."
   Good: "Starting with the TaskPane component. Reading bubble-tea skill first."
   ```

2. **Hedging everything**
   ```
   Bad:  "This might work, but there could be issues..."
   Good: "This works. Verified by running go build and manual testing."
   ```

3. **Listing obvious things**
   ```
   Bad:  "Tasks have: a name, a status, a date, an ID..."
   Good: [Just show the struct definition]
   ```

4. **Fake confidence**
   ```
   Bad:  "This is the best approach."
   Good: "Chose this approach because [specific reason]. Trade-off: [what we gave up]."
   ```

5. **Premature abstraction**
   ```
   Bad:  Creating AbstractTaskFactory when you have one task type
   Good: Start concrete, abstract when you have 3+ cases
   ```

### ‚úÖ Always Do

1. **State what you're doing and why**
2. **Show evidence (test output, benchmarks, screenshots)**
3. **Make decisions and own them**
4. **Acknowledge trade-offs explicitly**
5. **Cite sources for claims**

---

## üîç Explorer Agent: Anti-Patterns

### ‚ùå Surface-Level Exploration

```
Bad exploration:
"The codebase has a main.go file, some internal packages, and uses Bubble Tea."

Good exploration:
"Codebase structure:
- Entry: cmd/today/main.go (34 lines) - minimal, delegates to internal/ui
- State: internal/storage/ - JSON-based, no migrations, single-file per entity
- UI: internal/ui/ - 5 components, all follow same Init/Update/View pattern
- Gap identified: No error boundaries, panics crash the app
- Gap identified: Timer doesn't persist across restarts mid-session
- Question: Should we migrate to SQLite now or after v1.0?"
```

### ‚ùå Skipping the "Why"

```
Bad: "Other apps use SQLite so we should too."
Good: "taskwarrior moved to SQLite in v3 after JSON 'became slow and buggy' 
       at scale. Our JSON approach works now but won't scale past ~1000 tasks."
```

### Quality Checklist

- [ ] Mapped all relevant existing code
- [ ] Identified at least 3 unknowns or risks
- [ ] Found at least 2 prior art examples
- [ ] Listed specific questions needing answers
- [ ] Noted assumptions being made

---

## üìö Research Agent: Anti-Patterns

### ‚ùå Surface-Level Research

```
Bad: "Bubble Tea is a TUI framework for Go."
Good: "Bubble Tea implements Elm architecture:
       - Model holds all state (must be immutable conceptually)
       - Update MUST return quickly (<16ms for 60fps)
       - View is pure function, use strings.Builder (80x faster)
       - I/O goes in tea.Cmd, never in Update/View
       Source: charm.sh/blog/tea-architecture"
```

### ‚ùå Citing Without Verifying

```
Bad: "According to a blog post, this is the best approach..."
Good: "lazygit (56k stars) uses this pattern. Verified in their codebase:
       https://github.com/jesseduffield/lazygit/blob/master/pkg/gui/gui.go#L45"
```

### ‚ùå Outdated Information

```
Bad: "Use go-sqlite3 for SQLite."
Good: "Two options for SQLite in Go (2024):
       - mattn/go-sqlite3: Fastest, requires CGO, complex cross-compile
       - modernc.org/sqlite: Pure Go, 10-20% slower, trivial cross-compile
       For CLI distribution, modernc is better choice despite speed trade-off."
```

### Quality Checklist

- [ ] Used official documentation as primary source
- [ ] Verified claims in actual codebases
- [ ] Checked publication date of sources
- [ ] Noted conflicting information
- [ ] Provided actionable recommendations

---

## üé® Design Agent: Anti-Patterns

### ‚ùå Generic UI Patterns

```
Bad habit tracker:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ñ° Exercise      ‚îÇ
‚îÇ ‚ñ° Reading       ‚îÇ
‚îÇ ‚ñ° Meditation    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Good habit tracker:
‚îå‚îÄ HABITS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                          ‚îÇ
‚îÇ  üèÉ Exercise    ‚óã ‚óè ‚óè ‚óã ‚óè ‚óè ‚óè  5/7  üî• 3 ‚îÇ
‚îÇ  üìö Reading     ‚óè ‚óè ‚óã ‚óã ‚óè ‚óè ‚óã  4/7       ‚îÇ
‚îÇ  üßò Meditate    ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè  7/7  üî•12 ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÇ
‚îÇ                 M T W T F S S            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Why it's better:
- Shows history, not just current state
- Progress visible at a glance (visual week)
- Streaks create motivation
- Day labels give context
- Emoji adds personality without being childish
```

### ‚ùå No Visual Hierarchy

```
Bad: Everything same size, same weight, same color
Good: 
- Primary action: Bold + color
- Selected item: Background highlight + indicator
- Completed: Muted color + strikethrough
- Disabled: Dim, no interaction affordance
```

### ‚ùå Copying Without Understanding

```
Bad: "lazygit uses panels so we'll use panels"
Good: "lazygit uses panels because git has distinct concepts (files, commits, 
       branches) that benefit from parallel visibility. Our app has tasks, 
       timer, habits - also distinct concepts, panels make sense. BUT: unlike 
       lazygit, our concepts are less interconnected, so we can use simpler 
       tab-based focus instead of complex panel interactions."
```

### ‚ùå Decoration Over Function

```
Bad: Adding borders, colors, emoji everywhere because it "looks nice"
Good: Every visual element earns its place:
      - Border: Defines containment and focus
      - Color: Indicates state (active, done, error)
      - Emoji: Quick category recognition
      - Whitespace: Breathing room, groups related items
```

### ‚ùå Ignoring Terminal Constraints

```
Bad: Designing for 120 columns when users have 80
Bad: Using colors that clash on light terminals
Bad: Relying solely on color for state (accessibility)

Good: 
- Design for 80 columns minimum
- Use adaptive colors (light/dark variants)
- Combine color with shape/text ([x] vs [ ])
- Test on: macOS Terminal, iTerm, Windows Terminal, Linux TTY
```

### Design Quality Checklist

- [ ] Tested on 80-column terminal
- [ ] Works in light and dark themes
- [ ] No color-only indicators
- [ ] Clear visual hierarchy
- [ ] Whitespace is intentional
- [ ] Every element has a purpose
- [ ] Feels distinct, not generic
- [ ] Screenshot looks "designed"

---

## üèóÔ∏è Architect Agent: Anti-Patterns

### ‚ùå Architecture Astronautics

```
Bad: Creating plugin system, event bus, microservices for a CLI app
Good: Simple, direct code paths until complexity is proven necessary
```

### ‚ùå Resume-Driven Development

```
Bad: "Let's use gRPC, Protocol Buffers, and Kubernetes"
Good: "JSON files, single binary, runs locally. Add complexity when needed."
```

### ‚ùå Copying Architecture Blindly

```
Bad: "hexagonal architecture is best practice so we'll use it"
Good: "hexagonal architecture helps when you have multiple adapters 
       (web, CLI, tests). We only have CLI + tests, simple packages work.
       Revisit if we add API."
```

### ‚ùå Not Documenting Decisions

```
Bad: Code just appears in a certain structure
Good: ADR (Architecture Decision Record):
      "## Decision: Use JSON files over SQLite for v1.0
       
       ### Context
       Need persistent storage for tasks, habits, timer entries.
       
       ### Options
       1. JSON files - Simple, git-friendly, human-readable
       2. SQLite - Fast queries, migrations, atomic operations
       3. BoltDB - Fast, embedded, but binary format
       
       ### Decision
       JSON files for v1.0.
       
       ### Rationale
       - Users can read/edit their data
       - Easy backup (cp files)
       - Git sync is trivial
       - Acceptable performance for <1000 items
       
       ### Consequences
       - Must implement our own querying
       - No transactions (risk of corruption on crash)
       - Will need migration path to SQLite in v1.2"
```

### Quality Checklist

- [ ] Considered at least 3 options
- [ ] Trade-offs explicitly documented
- [ ] Decision rationale recorded
- [ ] Migration path identified
- [ ] Complexity justified by real need

---

## üíª Implementation Agent: Anti-Patterns

### ‚ùå Writing Code Before Understanding

```
Bad: Immediately start coding
Good: 
1. Read relevant skill files
2. Read existing code in the area
3. Write test cases first
4. Then implement
```

### ‚ùå Clever Code

```
Bad:
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    return map[reflect.Type]func(tea.Msg)(tea.Model,tea.Cmd){
        reflect.TypeOf(tea.KeyMsg{}): m.handleKey,
    }[reflect.TypeOf(msg)](msg)
}

Good:
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        return m.handleKey(msg)
    case tea.WindowSizeMsg:
        return m.handleResize(msg)
    default:
        return m, nil
    }
}
```

### ‚ùå Incomplete Error Handling

```
Bad:
data, _ := os.ReadFile(path)  // Ignoring error!

Good:
data, err := os.ReadFile(path)
if err != nil {
    if os.IsNotExist(err) {
        return defaultValue, nil  // Expected case: file doesn't exist yet
    }
    return nil, fmt.Errorf("reading %s: %w", path, err)
}
```

### ‚ùå Magic Numbers and Strings

```
Bad:
if len(items) > 50 {
    items = items[:50]
}
style.Foreground(lipgloss.Color("99"))

Good:
const maxVisibleItems = 50
if len(items) > maxVisibleItems {
    items = items[:maxVisibleItems]
}
style.Foreground(ColorPrimary)  // Defined in styles.go
```

### ‚ùå Copy-Paste Programming

```
Bad: Duplicating code because it's faster
Good: Extract shared logic, even if it takes longer now
```

### Quality Checklist

- [ ] Read relevant skill files first
- [ ] Tests written (or test plan documented)
- [ ] All errors handled with context
- [ ] No magic numbers
- [ ] No duplicated logic
- [ ] Comments explain "why" not "what"
- [ ] Runs without warnings

---

## üß™ Test Agent: Anti-Patterns

### ‚ùå Testing Implementation Details

```
Bad: Testing that internal slice has correct length
Good: Testing that user sees correct number of items
```

### ‚ùå Happy Path Only

```
Bad: Only testing with valid input
Good: Testing:
- Valid input (happy path)
- Empty input
- Nil/zero values
- Boundary conditions
- Invalid input
- Concurrent access (if applicable)
```

### ‚ùå Flaky Tests

```
Bad: Tests that depend on timing, random values, or external state
Good: Tests are deterministic and isolated
```

### ‚ùå Not Testing the UI

```
Bad: "TUI is too hard to test"
Good: Use teatest with golden files:
      - Capture expected output
      - Compare on every run
      - Update with -update flag when intentional changes
```

### Quality Checklist

- [ ] Tests cover critical paths
- [ ] Edge cases covered
- [ ] Tests are deterministic
- [ ] Golden files for UI
- [ ] Tests run in < 10 seconds
- [ ] Coverage measured

---

## üî¨ Review Agent: Anti-Patterns

### ‚ùå Rubber Stamping

```
Bad: "LGTM" without actually reviewing
Good: Structured review with specific observations
```

### ‚ùå Nitpicking Without Substance

```
Bad: "Could you rename 'x' to 'item'?" (unless actually confusing)
Good: "This function has 3 levels of nesting. Consider extracting 
       the inner loop to a helper method for readability."
```

### ‚ùå Missing the Forest for Trees

```
Bad: Focusing on style while missing a crash bug
Good: Priority order:
      1. Correctness (does it work?)
      2. Security (is it safe?)
      3. Performance (is it fast enough?)
      4. Maintainability (can we change it later?)
      5. Style (is it consistent?)
```

### Review Report Template

```markdown
## Review: [Component/PR Name]

### Summary
[One sentence: what was reviewed]

### Correctness
- [x] Logic is sound
- [ ] Issue: [describe]

### Error Handling  
- [x] All errors handled
- [ ] Missing: [describe]

### Tests
- [x] Critical paths tested
- [ ] Missing coverage: [describe]

### Style
- [x] Follows project patterns
- [ ] Inconsistency: [describe]

### Required Changes
1. [Must fix before merge]

### Suggestions (Optional)
1. [Nice to have]

### Verdict
[ ] Approved
[ ] Approved with comments  
[x] Changes requested
```

---

## Creating Exceptional Output

### The "Would I Use This?" Test

Before considering any work complete, ask:
- Would I want to use this every day?
- Would I recommend this to a friend?
- Would I be proud to show this in a portfolio?
- Does this feel like it was made by someone who cares?

### The "Stranger Test"

Imagine someone with no context sees this:
- Can they understand what it does in 5 seconds?
- Can they figure out how to use it in 30 seconds?
- Will they find any rough edges in 5 minutes of use?

### The "Future You" Test

Imagine reading this code in 6 months:
- Will you understand why decisions were made?
- Will you be able to modify it safely?
- Will you cringe or feel proud?

---

## Examples of Excellence vs Slop

### Code Comments

```
Slop:
// Increment counter
counter++

Excellence:
// Skip already-completed tasks to avoid double-counting in streak calculation.
// This can happen when tasks are synced from multiple devices.
```

### Error Messages

```
Slop:
return errors.New("error")

Excellence:
return fmt.Errorf("loading habits from %s: %w (file may be corrupted, try restoring from ~/.today/backups/)", path, err)
```

### UI Text

```
Slop:
"No items"

Excellence:
"No tasks yet. Press 'a' to add your first one."
```

### Documentation

```
Slop:
"This function does X."

Excellence:
"ParseTask extracts structured data from natural language input.

Examples:
  'Buy groceries'           ‚Üí Task{Text: 'Buy groceries'}
  'Call mom tomorrow'       ‚Üí Task{Text: 'Call mom', Due: tomorrow}
  '!high Fix auth bug'      ‚Üí Task{Text: 'Fix auth bug', Priority: High}

Limitations:
  - Dates must be relative ('tomorrow', 'next week') not absolute
  - Times are not supported yet (see issue #42)"
```

---

## Remember

The difference between forgettable software and beloved software is not features ‚Äî it's care. 

Every interaction should feel like someone thought about it.

**Be that someone.**
