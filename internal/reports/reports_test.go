// Package reports provides daily and weekly report generation for the today app.
// This file contains tests for report generation.
package reports

import (
	"encoding/json"
	"os"
	"strings"
	"testing"
	"time"

	"today/internal/storage"
)

// createTestStorage creates a temporary storage for testing.
func createTestStorage(t *testing.T) *storage.Storage {
	t.Helper()
	tmpDir := t.TempDir()
	store, err := storage.New(tmpDir)
	if err != nil {
		t.Fatalf("failed to create storage: %v", err)
	}
	return store
}

// setupTestData populates the storage with test data.
func setupTestData(t *testing.T, store *storage.Storage) {
	t.Helper()

	// Add some tasks
	store.AddTask("Complete project report", "Work", storage.PriorityHigh, nil)
	store.AddTask("Review PR", "Work", storage.PriorityMedium, nil)
	store.AddTask("Buy groceries", "", storage.PriorityLow, nil)

	// Complete one task
	tasks, _ := store.LoadTasks()
	if len(tasks.Tasks) > 0 {
		store.CompleteTask(tasks.Tasks[0].ID)
	}

	// Add habits
	store.AddHabit("Exercise", "ðŸƒ")
	store.AddHabit("Reading", "ðŸ“š")

	// Toggle one habit for today
	habits, _ := store.LoadHabits()
	if len(habits.Habits) > 0 {
		store.ToggleHabitToday(habits.Habits[0].ID)
	}

	// Add a timer entry
	store.StartTimer("Test Project")
	time.Sleep(10 * time.Millisecond)
	store.StopTimer()
}

// TestGenerator_DailyReport tests daily report generation.
func TestGenerator_DailyReport(t *testing.T) {
	store := createTestStorage(t)
	setupTestData(t, store)

	gen := NewGenerator(store)
	report, err := gen.GenerateDaily(time.Now())
	if err != nil {
		t.Fatalf("GenerateDaily() error: %v", err)
	}

	// Verify report fields
	if report.Date.IsZero() {
		t.Error("Expected non-zero date")
	}

	if report.GeneratedAt.IsZero() {
		t.Error("Expected non-zero generated_at")
	}

	// We added 3 tasks, completed 1
	if report.Tasks.CompletedCount != 1 {
		t.Errorf("Expected 1 completed task, got %d", report.Tasks.CompletedCount)
	}

	if report.Tasks.PendingCount != 2 {
		t.Errorf("Expected 2 pending tasks, got %d", report.Tasks.PendingCount)
	}

	// We added 2 habits, toggled 1
	if report.Habits.TotalCount != 2 {
		t.Errorf("Expected 2 habits, got %d", report.Habits.TotalCount)
	}

	if report.Habits.CompletedCount != 1 {
		t.Errorf("Expected 1 completed habit, got %d", report.Habits.CompletedCount)
	}
}

// TestGenerator_WeeklyReport tests weekly report generation.
func TestGenerator_WeeklyReport(t *testing.T) {
	store := createTestStorage(t)
	setupTestData(t, store)

	gen := NewGenerator(store)
	report, err := gen.GenerateWeekly(time.Now())
	if err != nil {
		t.Fatalf("GenerateWeekly() error: %v", err)
	}

	// Verify basic structure
	if report.StartDate.IsZero() {
		t.Error("Expected non-zero start date")
	}

	if len(report.Tasks.ByDay) != 7 {
		t.Errorf("Expected 7 days in ByDay, got %d", len(report.Tasks.ByDay))
	}

	if len(report.Time.ByDay) != 7 {
		t.Errorf("Expected 7 days in Time.ByDay, got %d", len(report.Time.ByDay))
	}

	if len(report.DailyBreakdown) != 7 {
		t.Errorf("Expected 7 days in DailyBreakdown, got %d", len(report.DailyBreakdown))
	}

	// Check habit days
	for _, h := range report.Habits.Habits {
		if len(h.DaysCompleted) != 7 {
			t.Errorf("Expected 7 days for habit %s, got %d", h.Name, len(h.DaysCompleted))
		}
	}
}

// TestFormatDailyMarkdown tests Markdown formatting.
func TestFormatDailyMarkdown(t *testing.T) {
	store := createTestStorage(t)
	setupTestData(t, store)

	gen := NewGenerator(store)
	report, _ := gen.GenerateDaily(time.Now())

	md := FormatDailyMarkdown(report)

	// Check for expected sections
	expectedSections := []string{
		"# Daily Report:",
		"## Tasks",
		"## Time Tracked",
		"## Habits",
		"---",
		"*Generated by today",
	}

	for _, section := range expectedSections {
		if !strings.Contains(md, section) {
			t.Errorf("Expected markdown to contain %q", section)
		}
	}

	// Check for completed task marker
	if !strings.Contains(md, "[x]") {
		t.Error("Expected markdown to contain completed task marker [x]")
	}
}

// TestFormatWeeklyMarkdown tests weekly Markdown formatting.
func TestFormatWeeklyMarkdown(t *testing.T) {
	store := createTestStorage(t)
	setupTestData(t, store)

	gen := NewGenerator(store)
	report, _ := gen.GenerateWeekly(time.Now())

	md := FormatWeeklyMarkdown(report)

	// Check for expected sections
	expectedSections := []string{
		"# Weekly Report:",
		"## Summary",
		"## Tasks by Day",
		"## Time by Day",
		"| Day |",
	}

	for _, section := range expectedSections {
		if !strings.Contains(md, section) {
			t.Errorf("Expected weekly markdown to contain %q", section)
		}
	}
}

// TestFormatDailyJSON tests JSON formatting.
func TestFormatDailyJSON(t *testing.T) {
	store := createTestStorage(t)
	setupTestData(t, store)

	gen := NewGenerator(store)
	report, _ := gen.GenerateDaily(time.Now())

	jsonData, err := FormatDailyJSON(report)
	if err != nil {
		t.Fatalf("FormatDailyJSON() error: %v", err)
	}

	// Verify JSON is valid
	var parsed map[string]interface{}
	if err := json.Unmarshal(jsonData, &parsed); err != nil {
		t.Fatalf("JSON output is not valid: %v", err)
	}

	// Check for expected keys
	expectedKeys := []string{"date", "tasks", "time", "habits", "generated_at"}
	for _, key := range expectedKeys {
		if _, ok := parsed[key]; !ok {
			t.Errorf("Expected JSON to contain key %q", key)
		}
	}
}

// TestFormatWeeklyJSON tests weekly JSON formatting.
func TestFormatWeeklyJSON(t *testing.T) {
	store := createTestStorage(t)
	setupTestData(t, store)

	gen := NewGenerator(store)
	report, _ := gen.GenerateWeekly(time.Now())

	jsonData, err := FormatWeeklyJSON(report)
	if err != nil {
		t.Fatalf("FormatWeeklyJSON() error: %v", err)
	}

	// Verify JSON is valid
	var parsed map[string]interface{}
	if err := json.Unmarshal(jsonData, &parsed); err != nil {
		t.Fatalf("JSON output is not valid: %v", err)
	}

	// Check for expected keys
	expectedKeys := []string{"start_date", "end_date", "tasks", "time", "habits", "daily_breakdown"}
	for _, key := range expectedKeys {
		if _, ok := parsed[key]; !ok {
			t.Errorf("Expected JSON to contain key %q", key)
		}
	}
}

// TestDateFiltering tests that tasks are filtered by date correctly.
func TestDateFiltering(t *testing.T) {
	store := createTestStorage(t)

	// Add and complete a task
	task, _ := store.AddTask("Test task", "", storage.PriorityNone, nil)
	store.CompleteTask(task.ID)

	gen := NewGenerator(store)

	// Report for today should include the task
	todayReport, _ := gen.GenerateDaily(time.Now())
	if todayReport.Tasks.CompletedCount != 1 {
		t.Errorf("Expected 1 completed task for today, got %d", todayReport.Tasks.CompletedCount)
	}

	// Report for yesterday should not include the task
	yesterday := time.Now().Add(-24 * time.Hour)
	yesterdayReport, _ := gen.GenerateDaily(yesterday)
	if yesterdayReport.Tasks.CompletedCount != 0 {
		t.Errorf("Expected 0 completed tasks for yesterday, got %d", yesterdayReport.Tasks.CompletedCount)
	}
}

// TestEmptyReport tests report generation with no data.
func TestEmptyReport(t *testing.T) {
	store := createTestStorage(t)

	gen := NewGenerator(store)
	report, err := gen.GenerateDaily(time.Now())
	if err != nil {
		t.Fatalf("GenerateDaily() error: %v", err)
	}

	// Empty report should work
	if report.Tasks.CompletedCount != 0 {
		t.Errorf("Expected 0 completed tasks, got %d", report.Tasks.CompletedCount)
	}

	if report.Habits.TotalCount != 0 {
		t.Errorf("Expected 0 habits, got %d", report.Habits.TotalCount)
	}

	// Markdown should still render
	md := FormatDailyMarkdown(report)
	if !strings.Contains(md, "# Daily Report:") {
		t.Error("Expected markdown header in empty report")
	}

	if !strings.Contains(md, "_No time tracked today._") {
		t.Error("Expected 'No time tracked' message in empty report")
	}
}

// TestHelperFunctions tests helper functions.
func TestHelperFunctions(t *testing.T) {
	// Test startOfDay
	now := time.Now()
	dayStart := startOfDay(now)
	if dayStart.Hour() != 0 || dayStart.Minute() != 0 || dayStart.Second() != 0 {
		t.Error("startOfDay should return midnight")
	}

	// Test startOfWeekSunday
	weekStart := startOfWeekSunday(now)
	if weekStart.Weekday() != time.Sunday {
		t.Errorf("startOfWeekSunday should return Sunday, got %s", weekStart.Weekday())
	}

	// Test overlapDuration
	rangeStart := time.Date(2025, 12, 15, 0, 0, 0, 0, time.Local)
	rangeEnd := time.Date(2025, 12, 16, 0, 0, 0, 0, time.Local)

	// Entry fully within range
	entryStart := time.Date(2025, 12, 15, 10, 0, 0, 0, time.Local)
	entryEnd := time.Date(2025, 12, 15, 12, 0, 0, 0, time.Local)
	overlap := overlapDuration(entryStart, entryEnd, rangeStart, rangeEnd)
	if overlap != 2*time.Hour {
		t.Errorf("Expected 2h overlap, got %v", overlap)
	}

	// Entry partially within range
	entryStart = time.Date(2025, 12, 14, 22, 0, 0, 0, time.Local)
	entryEnd = time.Date(2025, 12, 15, 2, 0, 0, 0, time.Local)
	overlap = overlapDuration(entryStart, entryEnd, rangeStart, rangeEnd)
	if overlap != 2*time.Hour {
		t.Errorf("Expected 2h overlap for partial entry, got %v", overlap)
	}

	// Entry outside range
	entryStart = time.Date(2025, 12, 14, 10, 0, 0, 0, time.Local)
	entryEnd = time.Date(2025, 12, 14, 12, 0, 0, 0, time.Local)
	overlap = overlapDuration(entryStart, entryEnd, rangeStart, rangeEnd)
	if overlap != 0 {
		t.Errorf("Expected 0 overlap for outside entry, got %v", overlap)
	}
}

// TestFormatDurationHuman tests human-readable duration formatting.
func TestFormatDurationHuman(t *testing.T) {
	tests := []struct {
		duration time.Duration
		expected string
	}{
		{30 * time.Minute, "30m"},
		{1 * time.Hour, "1h"},
		{90 * time.Minute, "1h 30m"},
		{2*time.Hour + 15*time.Minute, "2h 15m"},
		{0, "0m"},
	}

	for _, tc := range tests {
		result := formatDurationHuman(tc.duration)
		if result != tc.expected {
			t.Errorf("formatDurationHuman(%v) = %q, want %q", tc.duration, result, tc.expected)
		}
	}
}

// TestProjectGrouping tests that tasks/time are grouped by project.
func TestProjectGrouping(t *testing.T) {
	store := createTestStorage(t)

	// Add tasks to different projects
	task1, _ := store.AddTask("Task A", "ProjectA", storage.PriorityNone, nil)
	task2, _ := store.AddTask("Task B", "ProjectA", storage.PriorityNone, nil)
	task3, _ := store.AddTask("Task C", "ProjectB", storage.PriorityNone, nil)

	// Complete all
	store.CompleteTask(task1.ID)
	store.CompleteTask(task2.ID)
	store.CompleteTask(task3.ID)

	gen := NewGenerator(store)
	report, _ := gen.GenerateDaily(time.Now())

	// Check project grouping
	if len(report.Tasks.ByProject) < 2 {
		t.Errorf("Expected at least 2 projects, got %d", len(report.Tasks.ByProject))
	}

	// ProjectA should be first (most tasks)
	if report.Tasks.ByProject[0].Project != "ProjectA" {
		t.Errorf("Expected ProjectA first, got %s", report.Tasks.ByProject[0].Project)
	}

	if report.Tasks.ByProject[0].Count != 2 {
		t.Errorf("Expected 2 tasks for ProjectA, got %d", report.Tasks.ByProject[0].Count)
	}
}

// Ensure test directory is cleaned up
func TestMain(m *testing.M) {
	os.Exit(m.Run())
}
